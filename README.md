# Vex Language

<div align="center">
  <img src="assets/vex-logo.svg" alt="Vex Language Logo" width="128" height="128">
</div>

[![CI](https://github.com/thsfranca/vex/actions/workflows/ci.yml/badge.svg)](https://github.com/thsfranca/vex/actions/workflows/ci.yml)
[![Coverage](https://github.com/thsfranca/vex/actions/workflows/update-readme-coverage.yml/badge.svg)](https://github.com/thsfranca/vex/actions/workflows/update-readme-coverage.yml)
[![Go Report Card](https://goreportcard.com/badge/github.com/thsfranca/vex)](https://goreportcard.com/report/github.com/thsfranca/vex)
[![Release](https://img.shields.io/github/v/release/thsfranca/vex)](https://github.com/thsfranca/vex/releases)

A statically-typed functional programming language that transpiles to Go, designed for AI code generation and concurrent HTTP request handling, while exploring language implementation concepts and functional programming paradigms.

## Overview

Vex is an experimental programming language that combines functional programming principles with static typing, inspired by Lisp syntax and **specifically designed to be easily generated by AI models while handling multiple HTTP requests simultaneously**. It transpiles to Go for maximum performance and leverages S-expression syntax to create predictable, uniform code patterns that AI can reliably understand and generate for concurrent web services.

This is a **study project created for educational purposes and fun** - exploring how language design can optimize for AI code generation while building a complete language implementation from scratch.

### ðŸ¤– **AI-First + Concurrent HTTP Design Philosophy**

Vex is designed with two primary goals:

**ðŸ§  AI Code Generation**:
- **Uniform S-expression syntax**: Everything follows `(operation args...)` pattern, eliminating precedence rules and syntax complexity
- **Predictable structure**: Consistent patterns that AI models can learn and replicate reliably  
- **Semantic clarity**: Function names and operations clearly express intent
- **Composable building blocks**: Simple operations that combine into complex functionality
- **Minimal cognitive load**: Fewer syntax rules mean AI can focus on logic rather than parsing edge cases

**âš¡ Concurrent HTTP Performance**:
- **Goroutine-based concurrency**: Each HTTP request runs in its own lightweight thread
- **Functional immutability**: Thread-safe by design with immutable data structures
- **Go's performance**: Direct transpilation to Go for native concurrency and speed
- **Stateless patterns**: Functional design naturally supports concurrent request handling
- **Built-in HTTP patterns**: Language constructs optimized for web service development

## Project Structure

```
vex/
â”œâ”€â”€ cmd/                            # Command-line tools
â”‚   â””â”€â”€ vex-transpiler/             # Main transpiler CLI application
â”œâ”€â”€ internal/                       # Core implementation packages
â”‚   â””â”€â”€ transpiler/                 # Vex to Go transpiler engine
â”‚       â”œâ”€â”€ analysis/               # Semantic analysis (symbol table, errors)
â”‚       â”œâ”€â”€ ast/                    # AST wrapper for parser tree
â”‚       â”œâ”€â”€ codegen/                # Go code generation
â”‚       â”œâ”€â”€ macro/                  # Macro registry and expander
â”‚       â”œâ”€â”€ parser/                 # Generated ANTLR parser files
â”‚       â”œâ”€â”€ adapters.go             # Adapters bridging subsystems
â”‚       â”œâ”€â”€ interfaces.go           # Core interfaces (Parser, Analyzer, etc.)
â”‚       â”œâ”€â”€ orchestrator.go         # Builder and multi-stage pipeline
â”‚       â””â”€â”€ core.go                 # Public transpiler entrypoints
â”œâ”€â”€ core/                           # Core Vex standard library
â”‚   â””â”€â”€ core.vx                     # Standard library definitions
â”œâ”€â”€ docs/                           # Comprehensive documentation
â”‚   â”œâ”€â”€ getting-started.md          # Quick start tutorial
â”‚   â”œâ”€â”€ ai-quick-reference.md       # AI-optimized language reference
â”‚   â”œâ”€â”€ cli-reference.md            # Complete CLI tool documentation
â”‚   â”œâ”€â”€ grammar-reference.md        # Language grammar documentation
â”‚   â”œâ”€â”€ troubleshooting.md          # Common issues and solutions
â”‚   â”œâ”€â”€ known-bugs.md               # Bug tracking and workarounds
â”‚   â”œâ”€â”€ vex-implementation-requirements.md # Development roadmap
â”‚   â””â”€â”€ release-process.md          # Release automation documentation
â”œâ”€â”€ examples/                       # Example Vex programs
â”‚   â”œâ”€â”€ valid/                      # Valid syntax examples for testing
â”‚   â”œâ”€â”€ invalid/                    # Invalid syntax for parser validation
â”‚   â”œâ”€â”€ stdlib/                     # Standard library examples
â”‚   â””â”€â”€ go-usage/                   # Go integration examples
â”œâ”€â”€ tools/                          # Development and build tools
â”‚   â”œâ”€â”€ grammar/                    # ANTLR4 grammar definition (Vex.g4)
â”‚   â”œâ”€â”€ grammar-validator/          # Grammar validation with Go parser
â”‚   â”œâ”€â”€ coverage-updater/           # Test coverage automation
â”‚   â”œâ”€â”€ release-manager/            # Automated release management
â”‚   â”œâ”€â”€ change-detector/            # CI change detection
â”‚   â”œâ”€â”€ debug-helper/               # Development debugging utilities
â”‚   â”œâ”€â”€ extension-tester/           # VSCode extension testing
â”‚   â””â”€â”€ gen/                        # Generated parser files
â”œâ”€â”€ .github/                        # CI/CD infrastructure
â”‚   â”œâ”€â”€ workflows/                  # GitHub Actions workflows
â”‚   â””â”€â”€ scripts/                    # Extracted workflow scripts
â”œâ”€â”€ assets/                         # Project assets (logo, etc.)
â”œâ”€â”€ scripts/                        # Build and utility scripts
â”œâ”€â”€ coverage/                       # Test coverage reports
â””â”€â”€ vscode-extension/               # VSCode language support
```

## Language Vision

Vex aims to be a functional programming language optimized for AI generation and concurrent HTTP handling with:

- **AI-friendly syntax**: S-expressions provide uniform, predictable structure for AI models
- **Thread-safe by design**: Functional immutability means every program safely handles concurrent requests
- **Static typing** with type inference for performance and thread safety  
- **Semantic annotations**: Built-in metadata to guide AI code generation
- **Go transpilation** for native performance, concurrency, and ecosystem access
- **HTTP service focus** with built-in patterns for scalable web APIs and authentication
- **Composable patterns**: Simple building blocks that AI can combine into scalable solutions

### ðŸŽ¯ **Perfect for AI Code Generation + Concurrent HTTP**

Vex's design makes it ideal for AI-assisted development of concurrent web services:

```vex
;; AI can easily generate HTTP handlers that are naturally concurrent:
(defn api-endpoint [request]
  (-> request
      (validate-input)
      (process-data)            ; Always thread-safe by design
      (format-response)))

;; AI can generate HTTP servers that handle thousands of requests:
(http-server
  :port 8080
  :routes [
    (GET "/users" get-users)    ; Each request runs in its own goroutine
    (POST "/data" process-data) ; Thread-safe through immutable design
  ])
```

The uniform S-expression structure + functional design means AI models can:
- **Learn patterns quickly**: Same structure for all operations
- **Generate thread-safe code automatically**: Immutable data = no concurrency bugs
- **Scale automatically**: Every program handles thousands of concurrent requests
- **Focus on logic**: No syntax complexity, no concurrency complexity

### Current Status: Basic Transpiler Foundation âœ…

The project currently includes:
- **ANTLR4 grammar** for S-expressions, arrays, symbols, and strings
- **Basic transpiler** that converts core Vex constructs to Go
- **CLI tool** (`vex`) with `transpile`, `run`, and `build` commands
- **Core language features**:
  - Variable definitions: `(def x 10)` â†’ `x := 10`
  - Arithmetic expressions: `(+ 1 2)` â†’ `1 + 2`
  - Import system: `(import "fmt")` â†’ `import "fmt"`
  - Go function calls: `(fmt/Println "Hello")` â†’ `fmt.Println("Hello")`
  - Basic arrays: `[1 2 3]` â†’ `[]interface{}{1, 2, 3}`
  - Conditional expressions: `(if condition then else)` â†’ Go if statements
  - Sequential execution: `(do expr1 expr2)` â†’ Multiple Go statements
  - Basic macro system: `(macro name [params] body)` â†’ Macro registration and expansion
  - Function definitions: `(defn name [params] body)` â†’ Via built-in defn macro
- **Comprehensive CI/CD pipeline** with automated quality checks
- **Automated release process** with PR label-based version management  
- **Grammar validation system** testing both valid and invalid syntax
- **VSCode extension** with syntax highlighting and language support
- **Example programs** demonstrating working features

### Working Today ðŸš€

You can transpile, run, and build Vex programs:

```bash
# Build the transpiler
go build -o vex cmd/vex-transpiler/main.go

# Transpile to Go
echo '(def x (+ 5 3))' > example.vex
./vex transpile -input example.vex -output example.go

# Compile and execute everything
./vex run -input example.vex

# Build a binary executable
./vex build -input example.vex -output hello-world
```

Outputs valid Go code:
```go
package main

func main() {
    x := 5 + 3
}
```

**Command Overview:**
- **`transpile`** - Convert Vex source code to Go (for inspection or integration)
- **`run`** - Compile and execute Vex programs directly (includes core.vx if available)
- **`build`** - Create standalone binary executables from Vex programs

Current features working:
```vex
;; Import Go packages
(import "fmt")

;; Define variables with complex expressions
(def result (+ (* 10 5) (- 20 5)))

;; Call Go functions
(fmt/Println "Hello from Vex!")

;; Basic arrays
(def numbers [1 2 3 4])

;; Conditional expressions
(if true (fmt/Println "condition works") (fmt/Println "else"))

;; Sequential execution
(do
  (def x 10)
  (fmt/Println x))

;; Macro definitions
(macro greet [name] (fmt/Println "Hello" name))

;; Function definitions using defn macro
(defn add [x y] (+ x y))
```

### Next Phase ðŸš§

- **Enhanced function definitions** with proper type checking and semantics
- **Type system** with inference and checking for safety and performance
- **Enhanced semantic analysis** for better error reporting and optimization
- **AI-friendly HTTP patterns** with semantic annotations for endpoints
- **HTTP server framework** that AI can generate from simple descriptions
- **JWT authentication patterns** as the most market-valuable auth method
- **Immutable data structures** with structural sharing
- **Standard library** for common operations

#### In Progress: Package Discovery System (MVP)

- Directory-based packages: one package per directory; package name inferred from directory name
- Import resolution: resolve local Vex packages by directory path first; fall back to Go imports if not found
- Automatic package scanning: build a dependency graph starting from the entry file and topologically sort
- Circular dependency prevention: cycles are detected and reported as compile-time errors; the build fails
- CLI UX unchanged: `vex run` and `vex build` automatically include discovered packages

## Usage

### Prerequisites

- **Go 1.21+** for parser validation and tooling
- **ANTLR4** for grammar compilation (automatically installed in CI)
- **Node.js** (optional, for VSCode extension development)

### Development Commands

```bash
# Build the transpiler
make build-transpiler   # Build main Vex CLI tool

# Validate grammar with comprehensive testing
make validate-grammar   # Test both valid and invalid syntax examples

# Build all development tools
make build-tools       # Compile change-detector, coverage-updater, etc.

# Install VSCode extension
make install-extension # Install Vex language support

# Generate Go parser locally
make go                # Creates parser files for local development

# Run all tests
make test              # Execute test suite

# Clean generated files
make clean            # Remove all generated artifacts

# Show all available commands
make help             # Display detailed help
```

### Example Vex Code (Vision)

Here's what AI-friendly Vex programs might look like when fully implemented:

```vex
;; AI can easily generate HTTP endpoints that are inherently thread-safe
(defn get-user-profile
  ^{:http-endpoint "/api/users/:id"
    :method "GET"
    :auth-required true
    :returns "application/json"}
  [request]
  (-> request
      (extract-user-id)
      (fetch-user-from-db)         ; Always non-blocking
      (format-json-response)))

;; AI generates authentication that naturally handles thousands of logins
(defn login-endpoint
  ^{:purpose "authenticate-user"
    :security "high"
    :returns "jwt-token"}
  [request]
  (-> request
      (validate-credentials)
      (create-jwt-token)
      (json-response)))

;; AI composes systems that automatically scale to handle any load
(http-server
  :port 8080
  :routes [
    (GET "/api/users" list-users :jwt-auth)      ; Scales to millions of requests
    (POST "/api/login" login-endpoint)           ; Thread-safe by design
    (PUT "/api/users/:id" update-user :jwt-auth) ; No concurrency complexity
  ])
```

**Why AI-generated Vex code is naturally scalable:**
- **Uniform structure**: Everything is `(operation args...)` - always thread-safe
- **Immutable by default**: No shared mutable state = impossible to have concurrency bugs
- **Functional composition**: `(-> data transform1 transform2)` is inherently thread-safe
- **One pattern**: AI learns simple patterns that automatically scale
- **Go's goroutines**: Every AI-generated program scales to millions of requests

## Grammar Rules

The main grammar rules are:

- `program`: The root rule, matches one or more lists followed by EOF
- `list`: Matches `(` followed by elements followed by `)`
- `array`: Matches `[` followed by elements followed by `]`
- Elements can be: arrays, lists, symbols, or strings
- Supports arithmetic operators: `+`, `-`, `*`, `/`, and other symbols

## Learning Goals

This project explores key language implementation concepts with a focus on AI-friendly design:

- **AI-Optimized Language Design** - How to create syntax that AI models can reliably understand and generate
- **Lexing and Parsing** with ANTLR4 for uniform S-expression handling
- **Semantic Annotations** - Embedding meaning in code to guide AI generation
- **Type Systems** optimized for AI understanding and code generation
- **Code Generation** and transpilation to high-performance Go
- **HTTP Service Patterns** - Building AI-friendly frameworks for web development
- **Functional Programming** language design principles

## Implementation Roadmap

See [docs/vex-implementation-requirements.md](docs/vex-implementation-requirements.md) for the complete development plan, covering type systems, Go transpilation, immutable data structures, and production features. For the package system, see [docs/package-system.md](docs/package-system.md). For compiler error message conventions, see [docs/error-messages.md](docs/error-messages.md).

## AI Code Generation

For AI models and automated code generation, see [docs/ai-quick-reference.md](docs/ai-quick-reference.md) for a machine-readable language specification with structured examples, decision trees, and error prevention patterns.

## Project Status

**Current Phase**: Basic Transpiler Foundation + Macro System Complete (âœ… Phase 1-2, 4 Complete)  
**Next Phase**: Advanced Language Features (Phase 3: Type System & Semantic Analysis, Phase 5: Enhanced Functions)  
**Active Work**: Package Discovery System MVP (directory packages, import resolution, cycle detection; `vex.pkg` module root detection implemented)
**Timeline**: Personal study project for learning compiler concepts, developed for fun in spare time

### Infrastructure Achievements

âœ… **Grammar Foundation**
- ANTLR4 grammar with S-expression, array, and symbol support
- Automated parser generation and validation
- Test-driven grammar development with valid/invalid examples

âœ… **Basic Transpilation**
- Core Vex to Go transpilation working
- Variable definitions, arithmetic, imports, function calls
- CLI tool with transpile, run, and build commands

âœ… **Macro System**
- Basic macro definition and expansion
- User-defined macros with parameter substitution
- Built-in defn macro for function definitions

âœ… **Development Tooling** 
- Modular Go tools for CI/CD operations
- Grammar validator with detailed error reporting
- VSCode extension with syntax highlighting

âœ… **CI/CD Pipeline**
- Automated testing on all pull requests
- Grammar validation with positive/negative test cases
- Extension testing and quality gates
- Automated release management with semantic versioning

âœ… **Quality Standards**
- Extracted workflow logic into maintainable Go tools
- Comprehensive test coverage tracking
- Automated code quality enforcement

### Test Coverage Standard

This project enforces a single, simple coverage rule in CI:

- Overall coverage for `internal/transpiler` must be at least **85%**
- Generated parser code at `internal/transpiler/parser` is **excluded** from coverage
- PRs fail if coverage drops below the threshold

The PR report shows only the current coverage and the target threshold, in line with the projectâ€™s preference for simple coverage comments.

## Release Process

Vex uses an automated release system triggered by PR labels:

- **`release:patch`** - Bug fixes and minor improvements
- **`release:minor`** - New features and enhancements  
- **`release:major`** - Breaking changes

When a PR with a release label is merged to `main`, the system automatically:
1. Bumps the version number
2. Creates a Git tag
3. Generates release notes
4. Updates the changelog

See [docs/release-process.md](docs/release-process.md) for detailed information.

## Contributing

This is a personal study project, but feel free to:
- Test the grammar validation system
- Suggest language design ideas
- Report issues with the grammar or tooling
- Fork for your own experiments
- Try the editor support tools

**Note**: This is an educational project for learning compiler/language implementation concepts. It's not intended for production use - just for the joy of building a programming language from scratch!

---

## Editor Support

For development convenience, a VSCode extension is available in the `vscode-extension/` directory with syntax highlighting and file icons for `.vx` files.

```bash
cd vscode-extension && ./quick-install.sh
```
