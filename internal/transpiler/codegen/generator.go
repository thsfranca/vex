package codegen

import (
	"fmt"
	"strings"

	"github.com/antlr4-go/antlr/v4"
	"github.com/thsfranca/vex/internal/transpiler/analysis"
	"github.com/thsfranca/vex/internal/transpiler/parser"
)

// GoCodeGenerator generates Go code from AST
type GoCodeGenerator struct {
	output      strings.Builder
    imports     map[string]string
	goModules   map[string]string
	packageName string
	config      Config
    exports     map[string]map[string]bool // package -> exported symbols
}

// Config holds code generation configuration
type Config struct {
	PackageName      string
	GenerateComments bool
	IndentSize       int
    IgnoreImports    map[string]bool
    Exports          map[string]map[string]bool
}

// NewGoCodeGenerator creates a new Go code generator
func NewGoCodeGenerator(config Config) *GoCodeGenerator {
	return &GoCodeGenerator{
        imports:     make(map[string]string),
		goModules:   make(map[string]string),
		packageName: config.PackageName,
        config:      config,
        exports:     config.Exports,
	}
}

// Generate generates Go code from AST and symbol table
func (g *GoCodeGenerator) Generate(ast AST, symbols SymbolTable) (string, error) {
	// Reset for new generation
	g.output.Reset()
    g.imports = make(map[string]string)
	
	// Visit the AST
	if err := ast.Accept(g); err != nil {
		return "", err
	}
	
	return g.buildFinalCode(), nil
}

// AddImport adds an import to the generated code
func (g *GoCodeGenerator) AddImport(importPath string) {
    if _, exists := g.imports[importPath]; !exists {
        g.imports[importPath] = ""
    }
}

// SetPackageName sets the package name for generated code
func (g *GoCodeGenerator) SetPackageName(name string) {
	g.packageName = name
}

// VisitProgram generates code for a program node
func (g *GoCodeGenerator) VisitProgram(ctx *parser.ProgramContext) error {
	if g.config.GenerateComments {
		g.output.WriteString("// Generated by Vex transpiler\n")
	}
	
	// Count def statements to determine comment style
	defCount := 0
	for _, child := range ctx.GetChildren() {
		if listCtx, ok := child.(*parser.ListContext); ok {
			if g.isDefStatement(listCtx) {
				defCount++
			}
		}
	}
	
	currentDef := 0
	for _, child := range ctx.GetChildren() {
		if listCtx, ok := child.(*parser.ListContext); ok {
			value, err := g.VisitList(listCtx)
			if err != nil {
				return err
			}
			// Write the generated value to output
			if value != nil && value.String() != "" {
				// Special handling for def statements at top level
				if strings.Contains(value.String(), " := ") {
					g.output.WriteString(value.String() + "\n")
					// Extract variable name for implicit return
					parts := strings.Split(value.String(), " := ")
					if len(parts) >= 1 {
						varName := strings.TrimSpace(parts[0])
						currentDef++
						
						// Different comments for single vs multiple defs
						if defCount == 1 {
							g.output.WriteString(fmt.Sprintf("_ = %s // Return last defined value\n", varName))
						} else {
							g.output.WriteString(fmt.Sprintf("_ = %s // Use variable to satisfy Go compiler\n", varName))
						}
					}
				} else {
					// Special handling for certain statements that don't need assignments
					valueStr := value.String()
					if strings.HasPrefix(valueStr, "fmt.Println(") || 
					   strings.HasPrefix(valueStr, "fmt.Printf(") || 
					   strings.HasPrefix(valueStr, "\"import completed\"") {
						// Don't assign these to _
						if !strings.HasPrefix(valueStr, "\"import completed\"") {
							g.output.WriteString(valueStr + "\n")
						}
						// Skip import completed messages entirely
					} else {
						g.output.WriteString(fmt.Sprintf("_ = %s\n", valueStr))
					}
				}
			}
		}
	}
	return nil
}

// isDefStatement checks if a list context is a def statement
func (g *GoCodeGenerator) isDefStatement(ctx *parser.ListContext) bool {
	if ctx.GetChildCount() < 3 {
		return false
	}
	funcNameNode := ctx.GetChild(1)
	return g.nodeToString(funcNameNode) == "def"
}

// VisitList generates code for a list expression
func (g *GoCodeGenerator) VisitList(ctx *parser.ListContext) (Value, error) {
	childCount := ctx.GetChildCount()
	if childCount < 3 { // Need at least: '(', function, ')'
		return nil, nil
	}

	// Get function name (first child after '(')
	funcNameNode := ctx.GetChild(1)
	
	// Check if the function name is actually a nested expression
	if listCtx, ok := funcNameNode.(*parser.ListContext); ok {
		// This is a nested expression like ((+ 1 2) args...)
		// We need to evaluate the nested expression first
		funcResult, err := g.VisitList(listCtx)
		if err != nil {
			return nil, err
		}
		funcName := funcResult.String()
		
		// Extract arguments for the function call
		args := make([]string, 0, childCount-3)
		for i := 2; i < childCount-1; i++ { // Skip '(' and ')'
			child := ctx.GetChild(i)
			if child != nil {
				argValue, err := g.visitNode(child)
				if err != nil {
					return nil, err
				}
				args = append(args, argValue.String())
			}
		}
		
		// Generate function call with the evaluated function name
		argsStr := strings.Join(args, ", ")
		code := fmt.Sprintf("%s(%s)", funcName, argsStr)
		return analysis.NewBasicValue(code, "interface{}"), nil
	}
	
	funcName := g.nodeToString(funcNameNode)

	// Extract arguments - pre-allocate with estimated capacity
	args := make([]string, 0, childCount-3)
	for i := 2; i < childCount-1; i++ { // Skip '(' and ')'
		child := ctx.GetChild(i)
		if child != nil {
			// For macro definitions, don't visit children recursively
			if funcName == "macro" {
				// Just get the text representation
				args = append(args, g.nodeToString(child))
			} else {
				argValue, err := g.visitNode(child)
				if err != nil {
					return nil, err
				}
				args = append(args, argValue.String())
			}
		}
	}

	// Generate code based on function type
    switch funcName {
	case "def":
		return g.generateDef(args)
	case "if":
		return g.generateIf(args)
	case "do":
		return g.generateDo(args)
	case "fn":
		return g.generateFn(args)
	case "macro":
		return g.generateMacro(args)
	case "export":
		// Export is a compile-time declaration, no runtime code
		return analysis.NewBasicValue("", "void"), nil
	case "import":
        return g.generateImportFromCtx(ctx)
	case "+", "-", "*", "/":
		return g.generateArithmetic(funcName, args)
	case ">", "<", "=":
		return g.generateComparison(funcName, args)
	case "get", "slice", "len", "append":
		return g.generatePrimitiveOp(funcName, args)
	default:
		return g.generateFunctionCall(funcName, args)
	}
}

// VisitArray generates code for an array literal
func (g *GoCodeGenerator) VisitArray(ctx *parser.ArrayContext) (Value, error) {
	var elements []string
	
	// Process all children except '[' and ']'
	for i := 1; i < ctx.GetChildCount()-1; i++ {
		child := ctx.GetChild(i)
		if child != nil {
			elementValue, err := g.visitNode(child)
			if err != nil {
				return nil, err
			}
			elements = append(elements, elementValue.String())
		}
	}
	
	arrayCode := fmt.Sprintf("[]interface{}{%s}", strings.Join(elements, ", "))
	return analysis.NewBasicValue(arrayCode, "[]interface{}"), nil
}

// VisitTerminal generates code for a terminal node
func (g *GoCodeGenerator) VisitTerminal(node antlr.TerminalNode) (Value, error) {
	text := node.GetText()
	
	// Handle string literals
	if strings.HasPrefix(text, "\"") && strings.HasSuffix(text, "\"") {
		return analysis.NewBasicValue(text, "string"), nil
	}
	
	// Handle numbers
	if isNumber(text) {
		return analysis.NewBasicValue(text, "int"), nil
	}
	
	// Handle booleans
	if text == "true" || text == "false" {
		return analysis.NewBasicValue(text, "bool"), nil
	}
	
	// Handle symbols (convert hyphens to underscores for Go compatibility)
	goIdentifier := convertVexToGoIdentifier(text)
	return analysis.NewBasicValue(goIdentifier, "symbol"), nil
}

// Code generation methods for different constructs
func (g *GoCodeGenerator) generateDef(args []string) (Value, error) {
	if len(args) < 2 {
		return nil, fmt.Errorf("def requires name and value")
	}
	
	name := args[0]
	value := args[1]
	
	// Return assignment syntax for top-level processing
	result := name + " := " + value
	return analysis.NewBasicValue(result, "var"), nil
}

func (g *GoCodeGenerator) generateIf(args []string) (Value, error) {
	if len(args) < 2 {
		return nil, fmt.Errorf("if requires condition and then-branch")
	}
	
	condition := g.convertConditionToInfix(args[0])
	thenBranch := args[1]
	
	if len(args) > 2 {
		elseBranch := args[2]
		code := fmt.Sprintf("func() interface{} { if %s { return %s } else { return %s } }()", 
			condition, thenBranch, elseBranch)
		return analysis.NewBasicValue(code, "interface{}"), nil
	} else {
		code := fmt.Sprintf("func() interface{} { if %s { return %s } else { return nil } }()", 
			condition, thenBranch)
		return analysis.NewBasicValue(code, "interface{}"), nil
	}
}

// convertConditionToInfix converts function call format to infix for conditions
func (g *GoCodeGenerator) convertConditionToInfix(condition string) string {
	// Handle compile-time optimization for empty array checks
	if condition == "(len([]interface{}{}) == 0)" {
		return "true"
	}
	
	// No need for conversion anymore since comparisons already generate proper infix
	return condition
}

func (g *GoCodeGenerator) generateFn(args []string) (Value, error) {
	if len(args) < 2 {
		return nil, fmt.Errorf("fn requires parameter list and body")
	}
	
	paramList := args[0]
	body := args[1]
	
	// Parse parameter list
	params := g.parseParameterList(paramList)
	
	// Generate parameter declarations
	paramDecls := make([]string, len(params))
	for i, param := range params {
		paramDecls[i] = fmt.Sprintf("%s interface{}", param)
	}
	
	paramString := strings.Join(paramDecls, ", ")
	
	// Generate function literal
	code := fmt.Sprintf("func(%s) interface{} { return %s }", paramString, body)
	return analysis.NewBasicValue(code, "func"), nil
}

func (g *GoCodeGenerator) generateImport(args []string) (Value, error) {
    if len(args) < 1 {
        return nil, fmt.Errorf("import requires package path")
    }
    importPath := strings.Trim(args[0], "\"")
    g.AddImport(importPath)
    return analysis.NewBasicValue("\"import completed\" // Import statement result", "string"), nil
}

func (g *GoCodeGenerator) generateImportFromCtx(ctx *parser.ListContext) (Value, error) {
    if ctx.GetChildCount() < 3 {
        return nil, fmt.Errorf("import requires package path")
    }
    firstArg := ctx.GetChild(2)
    if arrayCtx, ok := firstArg.(*parser.ArrayContext); ok {
        for i := 1; i < arrayCtx.GetChildCount()-1; i++ {
            elem := arrayCtx.GetChild(i)
            if elem == nil {
                continue
            }
            if term, ok := elem.(antlr.TerminalNode); ok {
                t := term.GetText()
                if t == "," || t == "[" || t == "]" {
                    continue
                }
                if strings.HasPrefix(t, "\"") && strings.HasSuffix(t, "\"") {
                    p := strings.Trim(t, "\"")
                    g.AddImport(p)
                    continue
                }
            }
            switch n := elem.(type) {
            case *parser.ArrayContext, *parser.ListContext:
                path, alias := g.extractImportPair(n)
                if path != "" {
                    if alias != "" {
                        g.imports[path] = alias
                    } else {
                        g.AddImport(path)
                    }
                }
            }
        }
        return analysis.NewBasicValue("\"import completed\" // Import statement result", "string"), nil
    }
    if term, ok := firstArg.(antlr.TerminalNode); ok {
        t := term.GetText()
        if strings.HasPrefix(t, "\"") && strings.HasSuffix(t, "\"") {
            p := strings.Trim(t, "\"")
            g.AddImport(p)
            return analysis.NewBasicValue("\"import completed\" // Import statement result", "string"), nil
        }
    }
    return nil, fmt.Errorf("import requires package path")
}

func (g *GoCodeGenerator) extractImportPair(node antlr.Tree) (string, string) {
    var parts []string
    switch n := node.(type) {
    case *parser.ListContext:
        for i := 1; i < n.GetChildCount()-1; i++ {
            if t, ok := n.GetChild(i).(antlr.TerminalNode); ok {
                s := t.GetText()
                if s == "," {
                    continue
                }
                parts = append(parts, s)
            }
        }
    case *parser.ArrayContext:
        for i := 1; i < n.GetChildCount()-1; i++ {
            if t, ok := n.GetChild(i).(antlr.TerminalNode); ok {
                s := t.GetText()
                if s == "," {
                    continue
                }
                parts = append(parts, s)
            }
        }
    }
    if len(parts) == 0 {
        return "", ""
    }
    path := parts[0]
    if strings.HasPrefix(path, "\"") && strings.HasSuffix(path, "\"") {
        path = strings.Trim(path, "\"")
    }
    alias := ""
    if len(parts) >= 2 {
        alias = strings.Trim(parts[1], "\"")
    }
    return path, alias
}

func (g *GoCodeGenerator) generateArithmetic(op string, args []string) (Value, error) {
	if len(args) < 2 {
		return analysis.NewBasicValue("0", "int"), nil
	}
	
	// Left-associative chaining for multiple operands
	result := "(" + args[0] + " " + op + " " + args[1] + ")"
	for i := 2; i < len(args); i++ {
		result = "(" + result + " " + op + " " + args[i] + ")"
	}
	
	return analysis.NewBasicValue(result, "int"), nil
}

func (g *GoCodeGenerator) generateComparison(op string, args []string) (Value, error) {
	if len(args) < 2 {
		return analysis.NewBasicValue("false", "bool"), nil
	}
	
	// Convert Vex operators to Go operators
	goOp := op
	if op == "=" {
		goOp = "=="
	}
	
	// Generate infix format as expected by tests: (a == b)
	result := "(" + args[0] + " " + goOp + " " + args[1] + ")"
	return analysis.NewBasicValue(result, "bool"), nil
}

func (g *GoCodeGenerator) generateDo(args []string) (Value, error) {
	if len(args) == 0 {
		return analysis.NewBasicValue("func() interface{} { return nil }()", "interface{}"), nil
	}
	
	// Generate a function that executes all expressions and returns the last one
	var statements []string
	for i, arg := range args {
		// Convert def assignments to function call format inside do blocks
		processedArg := arg
		if strings.Contains(arg, " := ") {
			// Convert "x := 10" to "def(x, 10)"
			parts := strings.Split(arg, " := ")
			if len(parts) == 2 {
				processedArg = "def(" + strings.TrimSpace(parts[0]) + ", " + strings.TrimSpace(parts[1]) + ")"
			}
		}
		
		if i == len(args)-1 {
			// Last expression is the return value
			statements = append(statements, "return "+processedArg)
		} else {
			// Other expressions are executed for side effects
			statements = append(statements, processedArg)
		}
	}
	
	result := "func() interface{} { " + strings.Join(statements, "; ") + " }()"
	return analysis.NewBasicValue(result, "interface{}"), nil
}

func (g *GoCodeGenerator) generatePrimitiveOp(op string, args []string) (Value, error) {
	switch op {
	case "get":
		if len(args) < 2 {
			return analysis.NewBasicValue("nil", "interface{}"), nil
		}
		// Array/slice access with bounds checking
		code := fmt.Sprintf("func() interface{} { if len(%s) > %s { return %s[%s] } else { return nil } }()", args[0], args[1], args[0], args[1])
		return analysis.NewBasicValue(code, "interface{}"), nil
	case "slice":
		if len(args) < 2 {
			return analysis.NewBasicValue("[]interface{}{}", "[]interface{}"), nil
		}
		// Slice operation with bounds checking
		code := fmt.Sprintf("func() []interface{} { if len(%s) > %s { return %s[%s:] } else { return []interface{}{} } }()", args[0], args[1], args[0], args[1])
		return analysis.NewBasicValue(code, "[]interface{}"), nil
	case "len":
		if len(args) < 1 {
			return analysis.NewBasicValue("0", "int"), nil
		}
		// Simple len() function call
		code := fmt.Sprintf("len(%s)", args[0])
		return analysis.NewBasicValue(code, "int"), nil
	case "append":
		if len(args) < 2 {
			return analysis.NewBasicValue("[]interface{}{}", "[]interface{}"), nil
		}
		// Append operation - use spread operator for array arguments
		code := fmt.Sprintf("append(%s, %s...)", args[0], args[1])
		return analysis.NewBasicValue(code, "[]interface{}"), nil
	default:
		return analysis.NewBasicValue("nil", "interface{}"), nil
	}
}

func (g *GoCodeGenerator) generateFunctionCall(funcName string, args []string) (Value, error) {
    // Handle package/function notation with proper package identifier
    if strings.Contains(funcName, "/") {
        parts := strings.Split(funcName, "/")
        if len(parts) >= 2 {
            importPath := strings.Join(parts[:len(parts)-1], "/")
            function := parts[len(parts)-1]
            // If this is a local Vex package (marked to ignore in Go imports), call the function directly
            if g.config.IgnoreImports != nil && g.config.IgnoreImports[importPath] {
                // Enforce exports for local packages
                if ex, ok := g.exports[importPath]; ok {
                    if !ex[function] {
                        return nil, fmt.Errorf("symbol '%s' is not exported from package '%s'. Export it with (export [%s]) in that package.", function, importPath, function)
                    }
                }
                // Direct call by identifier (convert to Go-compatible)
                funcName = convertVexToGoIdentifier(function)
            } else if alias, ok := g.imports[importPath]; ok {
                pkgIdent := alias
                if pkgIdent == "" {
                    segs := strings.Split(importPath, "/")
                    pkgIdent = segs[len(segs)-1]
                }
                funcName = pkgIdent + "." + function

                // Enforce exports: if importPath is a local package (present in exports map)
                // then function must be exported
                if ex, ok := g.exports[importPath]; ok {
                    if !ex[function] {
                        return nil, fmt.Errorf("symbol '%s' is not exported from package '%s'. Export it with (export [%s]) in that package.", function, importPath, function)
                    }
                }
            } else {
                // Fallback: replace slashes with dots
                funcName = strings.ReplaceAll(funcName, "/", ".")
            }
        } else {
            funcName = strings.ReplaceAll(funcName, "/", ".")
        }
    }
	
	// Special case: handle variable access in packages (like os.Args)
	if len(args) == 0 && isPackageVariable(funcName) {
		// This is a variable access, not a function call
		code := funcName
		return analysis.NewBasicValue(code, "interface{}"), nil
	}
	
	// Generate function call
	argsStr := strings.Join(args, ", ")
	code := fmt.Sprintf("%s(%s)", funcName, argsStr)
	
	return analysis.NewBasicValue(code, "interface{}"), nil
}

// Helper methods
func (g *GoCodeGenerator) visitNode(node antlr.Tree) (Value, error) {
	switch n := node.(type) {
	case *parser.ListContext:
		return g.VisitList(n)
	case *parser.ArrayContext:
		return g.VisitArray(n)
	case antlr.TerminalNode:
		return g.VisitTerminal(n)
	default:
		return analysis.NewBasicValue("unknown", "interface{}"), nil
	}
}

func (g *GoCodeGenerator) nodeToString(node antlr.Tree) string {
	if terminal, ok := node.(antlr.TerminalNode); ok {
		return terminal.GetText()
	}
	if ctx, ok := node.(antlr.RuleNode); ok {
		return ctx.GetText()
	}
	return "unknown"
}

func (g *GoCodeGenerator) parseParameterList(paramList string) []string {
	// Handle array syntax [param1 param2] or []interface{}{param1, param2}
	trimmed := strings.TrimSpace(paramList)
	
	if strings.HasPrefix(trimmed, "[") && strings.HasSuffix(trimmed, "]") && !strings.Contains(trimmed, "interface{}") {
		// Vex format
		inner := strings.TrimSpace(trimmed[1 : len(trimmed)-1])
		if inner == "" {
			return []string{}
		}
		return strings.Fields(inner)
	} else if strings.HasPrefix(trimmed, "[]interface{}") {
		// Go format
		if start := strings.Index(trimmed, "}{"); start != -1 {
			start += 2
			if end := strings.LastIndex(trimmed, "}"); end > start {
				inner := strings.TrimSpace(trimmed[start:end])
				if inner == "" {
					return []string{}
				}
				params := strings.Split(inner, ",")
				for i, param := range params {
					params[i] = strings.TrimSpace(param)
				}
				return params
			}
		}
	}
	
	return []string{}
}

func (g *GoCodeGenerator) buildFinalCode() string {
	var result strings.Builder
	
	// Package declaration
	result.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))
	
    // Imports
    if len(g.imports) > 0 {
        for importPath, alias := range g.imports {
            if g.config.IgnoreImports != nil && g.config.IgnoreImports[importPath] {
                continue
            }
            if alias != "" {
                result.WriteString(fmt.Sprintf("import %s \"%s\"\n", alias, importPath))
            } else {
                result.WriteString(fmt.Sprintf("import \"%s\"\n", importPath))
            }
        }
        result.WriteString("\n")
    }
	
	// Main function
	result.WriteString("func main() {\n")
	
	// Add the generated code with proper indentation
	lines := strings.Split(g.output.String(), "\n")
	for _, line := range lines {
		if strings.TrimSpace(line) != "" {
			result.WriteString("\t" + line + "\n")
		}
	}
	
	result.WriteString("}\n")
	
	return result.String()
}

func isNumber(s string) bool {
	if len(s) == 0 {
		return false
	}
	for _, r := range s {
		if r < '0' || r > '9' {
			return false
		}
	}
	return true
}

// convertVexToGoIdentifier converts Vex identifiers (with hyphens) to Go identifiers (with underscores)
func convertVexToGoIdentifier(vexIdentifier string) string {
	return strings.ReplaceAll(vexIdentifier, "-", "_")
}

// isPackageVariable checks if a name refers to a package variable (not a function)
func isPackageVariable(name string) bool {
	// Known package variables
	packageVars := map[string]bool{
		"os.Args": true,
		// Add more as needed
	}
	return packageVars[name]
}

// Interface types (to avoid import cycles)
type AST interface {
	Accept(visitor ASTVisitor) error
}

type ASTVisitor interface {
	VisitProgram(ctx *parser.ProgramContext) error
	VisitList(ctx *parser.ListContext) (Value, error)
	VisitArray(ctx *parser.ArrayContext) (Value, error)
	VisitTerminal(node antlr.TerminalNode) (Value, error)
}

type Value interface {
	String() string
	Type() string
}

type SymbolTable interface {
	Define(name string, value Value) error
	Lookup(name string) (Value, bool)
	EnterScope()
	ExitScope()
}

// generateMacro handles macro definitions (compile-time constructs)
func (g *GoCodeGenerator) generateMacro(args []string) (Value, error) {
	// Macro definitions are compile-time constructs and don't generate runtime code
	// They are handled by the macro expansion phase, so we just return a no-op
	return analysis.NewBasicValue("", "void"), nil
}