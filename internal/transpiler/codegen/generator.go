package codegen

import (
	"fmt"
	"strings"

	"github.com/antlr4-go/antlr/v4"
	"github.com/thsfranca/vex/internal/transpiler/analysis"
	"github.com/thsfranca/vex/internal/transpiler/parser"
)

// GoCodeGenerator generates Go code from AST
// GoCodeGenerator traverses Vex AST and emits idiomatic Go source code.
type GoCodeGenerator struct {
	output      strings.Builder
	imports     map[string]string
	packageName string
	config      Config
	exports     map[string]map[string]bool // package -> exported symbols
}

// Config holds code generation configuration
// Config tunes code generation output (package, comments, indentation, imports/exports).
type Config struct {
	PackageName      string
	GenerateComments bool
	IndentSize       int
	IgnoreImports    map[string]bool
	Exports          map[string]map[string]bool
}

// NewGoCodeGenerator creates a new Go code generator
// NewGoCodeGenerator creates a generator using the provided configuration.
func NewGoCodeGenerator(config Config) *GoCodeGenerator {
	return &GoCodeGenerator{
		imports:     make(map[string]string),
		packageName: config.PackageName,
		config:      config,
		exports:     config.Exports,
	}
}

// Generate generates Go code from AST and symbol table
func (g *GoCodeGenerator) Generate(ast AST, symbols SymbolTable) (string, error) {
	// Reset for new generation
	g.output.Reset()
	g.imports = make(map[string]string)

	// Visit the AST
	if err := ast.Accept(g); err != nil {
		return "", err
	}

	return g.buildFinalCode(), nil
}

// AddImport adds an import to the generated code
func (g *GoCodeGenerator) AddImport(importPath string) {
	if _, exists := g.imports[importPath]; !exists {
		g.imports[importPath] = ""
	}
}

// SetPackageName sets the package name for generated code
func (g *GoCodeGenerator) SetPackageName(name string) {
	g.packageName = name
}

// VisitProgram generates code for a program node
func (g *GoCodeGenerator) VisitProgram(ctx *parser.ProgramContext) error {
	if g.config.GenerateComments {
		g.output.WriteString("// Generated by Vex transpiler\n")
	}

	// Count def statements to determine comment style
	defCount := 0
	for _, child := range ctx.GetChildren() {
		if listCtx, ok := child.(*parser.ListContext); ok {
			if g.isDefStatement(listCtx) {
				defCount++
			}
		}
	}

	currentDef := 0
	for _, child := range ctx.GetChildren() {
		if listCtx, ok := child.(*parser.ListContext); ok {
			value, err := g.VisitList(listCtx)
			if err != nil {
				return err
			}
			// Write the generated value to output
			if value != nil && value.String() != "" {
				valueStr := value.String()

				// Check if this is a simple top-level def (not a complex expression)
				isSimpleDef := strings.Contains(valueStr, " := ") &&
					!strings.Contains(valueStr, "func() interface{}") &&
					!strings.Contains(valueStr, "return ")

				if isSimpleDef {
					// Simple top-level definition like: x := 42
					g.output.WriteString(valueStr + "\n")
					// Extract variable name for implicit return
					parts := strings.Split(valueStr, " := ")
					if len(parts) >= 1 {
						varName := strings.TrimSpace(parts[0])
						currentDef++

						// Different comments for single vs multiple defs
						if defCount == 1 {
							g.output.WriteString(fmt.Sprintf("_ = %s // Return last defined value\n", varName))
						} else {
							g.output.WriteString(fmt.Sprintf("_ = %s // Use variable to satisfy Go compiler\n", varName))
						}
					}
				} else {
					// Complex expressions (function literals, etc.) or simple statements
					if strings.HasPrefix(valueStr, "fmt.Println(") ||
						strings.HasPrefix(valueStr, "fmt.Printf(") ||
						strings.HasPrefix(valueStr, "\"import completed\"") {
						// Don't assign these to _
						if !strings.HasPrefix(valueStr, "\"import completed\"") {
							g.output.WriteString(valueStr + "\n")
						}
						// Skip import completed messages entirely
					} else {
						g.output.WriteString(fmt.Sprintf("_ = %s\n", valueStr))
					}
				}
			}
		}
	}
	return nil
}

// isDefStatement checks if a list context is a def statement
func (g *GoCodeGenerator) isDefStatement(ctx *parser.ListContext) bool {
	if ctx.GetChildCount() < 3 {
		return false
	}
	funcNameNode := ctx.GetChild(1)
	return g.nodeToString(funcNameNode) == "def"
}

// VisitList generates code for a list expression
func (g *GoCodeGenerator) VisitList(ctx *parser.ListContext) (Value, error) {
	childCount := ctx.GetChildCount()
	if childCount < 3 { // Need at least: '(', function, ')'
		return nil, nil
	}

	// Get function name (first child after '(')
	funcNameNode := ctx.GetChild(1)

	// Check if the function name is actually a nested expression
	if listCtx, ok := funcNameNode.(*parser.ListContext); ok {
		// This is a nested expression like ((+ 1 2) args...)
		// We need to evaluate the nested expression first
		funcResult, err := g.VisitList(listCtx)
		if err != nil {
			return nil, err
		}
		funcName := funcResult.String()

		// Extract arguments for the function call
		args := make([]string, 0, childCount-3)
		for i := 2; i < childCount-1; i++ { // Skip '(' and ')'
			child := ctx.GetChild(i)
			if child != nil {
				argValue, err := g.visitNode(child)
				if err != nil {
					return nil, err
				}
				args = append(args, argValue.String())
			}
		}

		// Generate function call with the evaluated function name
		argsStr := strings.Join(args, ", ")
		code := fmt.Sprintf("%s(%s)", funcName, argsStr)
		return analysis.NewBasicValue(code, "interface{}"), nil
	}

	funcName := g.nodeToString(funcNameNode)

	// Extract arguments - pre-allocate with estimated capacity
	args := make([]string, 0, childCount-3)
	for i := 2; i < childCount-1; i++ { // Skip '(' and ')'
		child := ctx.GetChild(i)
		if child != nil {
			// For macro definitions, don't visit children recursively
			if funcName == "macro" {
				// Just get the text representation
				args = append(args, g.nodeToString(child))
			} else {
				argValue, err := g.visitNode(child)
				if err != nil {
					return nil, err
				}
				args = append(args, argValue.String())
			}
		}
	}

	// Generate code based on function type
	switch funcName {
	case "def":
		return g.generateDef(args)
	case "if":
		return g.generateIf(args)
	case "do":
		return g.generateDo(args)
	case "fn":
		return g.generateFn(args)
	case "macro":
		return g.generateMacro(args)
	case "export":
		// Export is a compile-time declaration, no runtime code
		return analysis.NewBasicValue("", "void"), nil
	case "import":
		return g.generateImportFromCtx(ctx)
	case "+", "-", "*", "/":
		return g.generateArithmetic(funcName, args)
	case ">", "<", "=":
		return g.generateComparison(funcName, args)
	case "get", "slice", "len", "append":
		return g.generatePrimitiveOp(funcName, args)
	case "empty?", "count", "first", "rest", "cons":
		return g.generateCollectionOp(funcName, args)
	default:
		// Optional specialization: if the call is a pure comparison, emit bool directly
		// Otherwise fallback
		return g.generateFunctionCall(funcName, args)
	}
}

// VisitArray generates code for an array literal
func (g *GoCodeGenerator) VisitArray(ctx *parser.ArrayContext) (Value, error) {
	var elements []string

	// Process all children except '[' and ']'
	for i := 1; i < ctx.GetChildCount()-1; i++ {
		child := ctx.GetChild(i)
		if child != nil {
			elementValue, err := g.visitNode(child)
			if err != nil {
				return nil, err
			}
			elements = append(elements, elementValue.String())
		}
	}

	arrayCode := fmt.Sprintf("[]interface{}{%s}", strings.Join(elements, ", "))
	return analysis.NewBasicValue(arrayCode, "[]interface{}"), nil
}

// VisitTerminal generates code for a terminal node
func (g *GoCodeGenerator) VisitTerminal(node antlr.TerminalNode) (Value, error) {
	text := node.GetText()

	// Handle string literals
	if strings.HasPrefix(text, "\"") && strings.HasSuffix(text, "\"") {
		return analysis.NewBasicValue(text, "string"), nil
	}

	// Handle numbers
	if isNumber(text) {
		return analysis.NewBasicValue(text, "int"), nil
	}

	// Handle booleans
	if text == "true" || text == "false" {
		return analysis.NewBasicValue(text, "bool"), nil
	}

	// Handle symbols (convert hyphens to underscores for Go compatibility)
	goIdentifier := convertVexToGoIdentifier(text)
	return analysis.NewBasicValue(goIdentifier, "symbol"), nil
}

// Code generation methods for different constructs
func (g *GoCodeGenerator) generateDef(args []string) (Value, error) {
	if len(args) < 2 {
		return nil, fmt.Errorf("def requires name and value")
	}

	name := args[0]
	value := args[1]

	// Return assignment syntax for top-level processing
	result := name + " := " + value
	return analysis.NewBasicValue(result, "var"), nil
}

func (g *GoCodeGenerator) generateIf(args []string) (Value, error) {
	if len(args) < 2 {
		return nil, fmt.Errorf("if requires condition and then-branch")
	}

	condition := g.convertConditionToInfix(args[0])
	thenBranch := args[1]

	if len(args) > 2 {
		elseBranch := args[2]
		code := fmt.Sprintf("func() interface{} { if %s { return %s } else { return %s } }()",
			condition, thenBranch, elseBranch)
		return analysis.NewBasicValue(code, "interface{}"), nil
	} else {
		code := fmt.Sprintf("func() interface{} { if %s { return %s } else { return nil } }()",
			condition, thenBranch)
		return analysis.NewBasicValue(code, "interface{}"), nil
	}
}

// convertConditionToInfix converts function call format to infix for conditions
func (g *GoCodeGenerator) convertConditionToInfix(condition string) string {
	// Handle compile-time optimization for empty array checks
	if condition == "(len([]interface{}{}) == 0)" {
		return "true"
	}

	// No need for conversion anymore since comparisons already generate proper infix
	return condition
}

func (g *GoCodeGenerator) generateFn(args []string) (Value, error) {
	if len(args) < 2 {
		return nil, fmt.Errorf("fn requires parameter list and body")
	}

	paramList := args[0]
	var body string

	// Handle explicit type syntax only: (fn [params] _> returnType body)
	// Note: analyzer converts -> to _>
	if len(args) == 4 && args[1] == "_>" {
		// Explicit type syntax: (fn [params] _> returnType body)
		// returnType := args[2] // For now, ignore return type in codegen
		body = args[3]
	} else {
		return nil, fmt.Errorf("fn requires explicit return type annotation: [params] -> returnType body, got %d args", len(args))
	}

	// Parse parameter list
	params := g.parseParameterList(paramList)
	if params == nil {
		return nil, fmt.Errorf("function parameters require explicit type annotations (param: type)")
	}

	// Generate parameter declarations
	paramDecls := make([]string, len(params))
	for i, param := range params {
		paramDecls[i] = fmt.Sprintf("%s interface{}", param)
	}

	paramString := strings.Join(paramDecls, ", ")

	// Generate function literal
	code := fmt.Sprintf("func(%s) interface{} { return %s }", paramString, body)
	return analysis.NewBasicValue(code, "func"), nil
}

func (g *GoCodeGenerator) generateImport(args []string) (Value, error) {
	if len(args) < 1 {
		return nil, fmt.Errorf("import requires package path")
	}
	importPath := strings.Trim(args[0], "\"")
	g.AddImport(importPath)
	return analysis.NewBasicValue("\"import completed\" // Import statement result", "string"), nil
}

func (g *GoCodeGenerator) generateImportFromCtx(ctx *parser.ListContext) (Value, error) {
	if ctx.GetChildCount() < 3 {
		return nil, fmt.Errorf("import requires package path")
	}
	firstArg := ctx.GetChild(2)
	if arrayCtx, ok := firstArg.(*parser.ArrayContext); ok {
		for i := 1; i < arrayCtx.GetChildCount()-1; i++ {
			elem := arrayCtx.GetChild(i)
			if elem == nil {
				continue
			}
			if term, ok := elem.(antlr.TerminalNode); ok {
				t := term.GetText()
				if t == "," || t == "[" || t == "]" {
					continue
				}
				if strings.HasPrefix(t, "\"") && strings.HasSuffix(t, "\"") {
					p := strings.Trim(t, "\"")
					g.AddImport(p)
					continue
				}
			}
			switch n := elem.(type) {
			case *parser.ArrayContext, *parser.ListContext:
				path, alias := g.extractImportPair(n)
				if path != "" {
					if alias != "" {
						g.imports[path] = alias
					} else {
						g.AddImport(path)
					}
				}
			}
		}
		return analysis.NewBasicValue("\"import completed\" // Import statement result", "string"), nil
	}
	if term, ok := firstArg.(antlr.TerminalNode); ok {
		t := term.GetText()
		if strings.HasPrefix(t, "\"") && strings.HasSuffix(t, "\"") {
			p := strings.Trim(t, "\"")
			g.AddImport(p)
			return analysis.NewBasicValue("\"import completed\" // Import statement result", "string"), nil
		}
	}
	return nil, fmt.Errorf("import requires package path")
}

func (g *GoCodeGenerator) extractImportPair(node antlr.Tree) (string, string) {
	var parts []string
	switch n := node.(type) {
	case *parser.ListContext:
		for i := 1; i < n.GetChildCount()-1; i++ {
			if t, ok := n.GetChild(i).(antlr.TerminalNode); ok {
				s := t.GetText()
				if s == "," {
					continue
				}
				parts = append(parts, s)
			}
		}
	case *parser.ArrayContext:
		for i := 1; i < n.GetChildCount()-1; i++ {
			if t, ok := n.GetChild(i).(antlr.TerminalNode); ok {
				s := t.GetText()
				if s == "," {
					continue
				}
				parts = append(parts, s)
			}
		}
	}
	if len(parts) == 0 {
		return "", ""
	}
	path := parts[0]
	if strings.HasPrefix(path, "\"") && strings.HasSuffix(path, "\"") {
		path = strings.Trim(path, "\"")
	}
	alias := ""
	if len(parts) >= 2 {
		alias = strings.Trim(parts[1], "\"")
	}
	return path, alias
}

func (g *GoCodeGenerator) generateArithmetic(op string, args []string) (Value, error) {
	if len(args) < 2 {
		return analysis.NewBasicValue("0", "int"), nil
	}

	// Left-associative chaining for multiple operands
	result := "(" + args[0] + " " + op + " " + args[1] + ")"
	for i := 2; i < len(args); i++ {
		result = "(" + result + " " + op + " " + args[i] + ")"
	}

	return analysis.NewBasicValue(result, "int"), nil
}

func (g *GoCodeGenerator) generateComparison(op string, args []string) (Value, error) {
	if len(args) < 2 {
		return analysis.NewBasicValue("false", "bool"), nil
	}

	// Convert Vex operators to Go operators
	goOp := op
	if op == "=" {
		goOp = "=="
	}

	// Generate infix format as expected by tests: (a == b)
	result := "(" + args[0] + " " + goOp + " " + args[1] + ")"
	return analysis.NewBasicValue(result, "bool"), nil
}

func (g *GoCodeGenerator) generateDo(args []string) (Value, error) {
	if len(args) == 0 {
		return analysis.NewBasicValue("func() interface{} { return nil }()", "interface{}"), nil
	}

	// Generate a function that executes all expressions and returns the last one
	var statements []string
	for i, arg := range args {
		processedArg := arg

		// Handle def assignments - keep function assignments as Go variable assignments
		if strings.Contains(arg, " := ") {
			parts := strings.Split(arg, " := ")
			if len(parts) == 2 {
				varName := strings.TrimSpace(parts[0])
				varValue := strings.TrimSpace(parts[1])

				// Check if this is a function assignment
				if strings.Contains(varValue, "func(") {
					// Keep function assignments as variable assignments
					processedArg = fmt.Sprintf("%s := %s", varName, varValue)
				} else {
					// For simple values, we can also keep as assignment
					processedArg = fmt.Sprintf("%s := %s", varName, varValue)
				}
			}
		}

		if i == len(args)-1 {
			// Last expression is the return value
			if strings.Contains(processedArg, " := ") {
				// If the last statement is a definition, execute it and return the variable
				parts := strings.Split(processedArg, " := ")
				if len(parts) == 2 {
					varName := strings.TrimSpace(parts[0])
					statements = append(statements, processedArg)
					statements = append(statements, fmt.Sprintf("return %s", varName))
				} else {
					statements = append(statements, "return "+processedArg)
				}
			} else {
				statements = append(statements, "return "+processedArg)
			}
		} else {
			// Other expressions are executed for side effects
			statements = append(statements, processedArg)
		}
	}

	result := "func() interface{} { " + strings.Join(statements, "; ") + " }()"
	return analysis.NewBasicValue(result, "interface{}"), nil
}

func (g *GoCodeGenerator) generatePrimitiveOp(op string, args []string) (Value, error) {
	switch op {
	case "get":
		if len(args) < 2 {
			return analysis.NewBasicValue("nil", "interface{}"), nil
		}
		// Array/slice access with bounds checking
		code := fmt.Sprintf("func() interface{} { if len(%s) > %s { return %s[%s] } else { return nil } }()", args[0], args[1], args[0], args[1])
		return analysis.NewBasicValue(code, "interface{}"), nil
	case "slice":
		if len(args) < 2 {
			return analysis.NewBasicValue("[]interface{}{}", "[]interface{}"), nil
		}
		// Slice operation with bounds checking
		code := fmt.Sprintf("func() []interface{} { if len(%s) > %s { return %s[%s:] } else { return []interface{}{} } }()", args[0], args[1], args[0], args[1])
		return analysis.NewBasicValue(code, "[]interface{}"), nil
	case "len":
		if len(args) < 1 {
			return analysis.NewBasicValue("0", "int"), nil
		}
		// Simple len() function call
		code := fmt.Sprintf("len(%s)", args[0])
		return analysis.NewBasicValue(code, "int"), nil
	case "append":
		if len(args) < 2 {
			return analysis.NewBasicValue("[]interface{}{}", "[]interface{}"), nil
		}
		// Append operation - use spread operator for array arguments
		code := fmt.Sprintf("append(%s, %s...)", args[0], args[1])
		return analysis.NewBasicValue(code, "[]interface{}"), nil
	default:
		return analysis.NewBasicValue("nil", "interface{}"), nil
	}
}

func (g *GoCodeGenerator) generateCollectionOp(op string, args []string) (Value, error) {
	switch op {
	case "empty?":
		if len(args) != 1 {
			return analysis.NewBasicValue("false", "bool"), nil
		}
		// Check for empty array literal: []interface{}{}
		if args[0] == "[]interface{}{}" {
			return analysis.NewBasicValue("true", "bool"), nil
		}
		// Generate standard Go len() check
		code := fmt.Sprintf("(len(%s) == 0)", args[0])
		return analysis.NewBasicValue(code, "bool"), nil
	case "count":
		if len(args) != 1 {
			return analysis.NewBasicValue("0", "int"), nil
		}
		// Generate standard Go len() call
		code := fmt.Sprintf("len(%s)", args[0])
		return analysis.NewBasicValue(code, "int"), nil
	case "first":
		if len(args) != 1 {
			return analysis.NewBasicValue("nil", "interface{}"), nil
		}
		// Generate first element access with bounds checking using standard Go
		code := fmt.Sprintf("func() interface{} { if len(%s) > 0 { return %s[0] } else { return nil } }()", args[0], args[0])
		return analysis.NewBasicValue(code, "interface{}"), nil
	case "rest":
		if len(args) != 1 {
			return analysis.NewBasicValue("[]interface{}{}", "[]interface{}"), nil
		}
		// Generate rest operation using standard Go slicing
		code := fmt.Sprintf("func() []interface{} { if len(%s) > 1 { return %s[1:] } else { return []interface{}{} } }()", args[0], args[0])
		return analysis.NewBasicValue(code, "[]interface{}"), nil
	case "cons":
		if len(args) != 2 {
			return analysis.NewBasicValue("[]interface{}{}", "[]interface{}"), nil
		}
		// Generate cons operation using standard Go append
		code := fmt.Sprintf("append([]interface{}{%s}, %s...)", args[0], args[1])
		return analysis.NewBasicValue(code, "[]interface{}"), nil
	default:
		return analysis.NewBasicValue("nil", "interface{}"), nil
	}
}

func (g *GoCodeGenerator) generateFunctionCall(funcName string, args []string) (Value, error) {
	// Handle package/function notation with proper package identifier
	if strings.Contains(funcName, "/") {
		parts := strings.Split(funcName, "/")
		if len(parts) >= 2 {
			importPath := strings.Join(parts[:len(parts)-1], "/")
			function := parts[len(parts)-1]
			// If this is a local Vex package (marked to ignore in Go imports), call the function directly
			if g.config.IgnoreImports != nil && g.config.IgnoreImports[importPath] {
				// Enforce exports for local packages
				if ex, ok := g.exports[importPath]; ok {
					if !ex[function] {
						return nil, fmt.Errorf("[PACKAGE-NOT-EXPORTED]: symbol '%s' is not exported from package '%s'\nSuggestion: Export it with (export [%s]) in that package.", function, importPath, function)
					}
				}
				// Direct call by identifier (convert to Go-compatible)
				funcName = convertVexToGoIdentifier(function)
			} else if alias, ok := g.imports[importPath]; ok {
				pkgIdent := alias
				if pkgIdent == "" {
					segs := strings.Split(importPath, "/")
					pkgIdent = segs[len(segs)-1]
				}
				funcName = pkgIdent + "." + function

				// Enforce exports: if importPath is a local package (present in exports map)
				// then function must be exported
				if ex, ok := g.exports[importPath]; ok {
					if !ex[function] {
						return nil, fmt.Errorf("[PACKAGE-NOT-EXPORTED]: symbol '%s' is not exported from package '%s'\nSuggestion: Export it with (export [%s]) in that package.", function, importPath, function)
					}
				}
			} else {
				// Fallback: replace slashes with dots
				funcName = strings.ReplaceAll(funcName, "/", ".")
			}
		} else {
			funcName = strings.ReplaceAll(funcName, "/", ".")
		}
	}

	// Special case: handle variable access in packages (like os.Args)
	if len(args) == 0 && isPackageVariable(funcName) {
		// This is a variable access, not a function call
		code := funcName
		return analysis.NewBasicValue(code, "interface{}"), nil
	}

	// Generate function call
	argsStr := strings.Join(args, ", ")
	code := fmt.Sprintf("%s(%s)", funcName, argsStr)

	return analysis.NewBasicValue(code, "interface{}"), nil
}

// Helper methods
func (g *GoCodeGenerator) visitNode(node antlr.Tree) (Value, error) {
	switch n := node.(type) {
	case *parser.ListContext:
		return g.VisitList(n)
	case *parser.ArrayContext:
		return g.VisitArray(n)
	case antlr.TerminalNode:
		return g.VisitTerminal(n)
	default:
		return analysis.NewBasicValue("unknown", "interface{}"), nil
	}
}

func (g *GoCodeGenerator) nodeToString(node antlr.Tree) string {
	if terminal, ok := node.(antlr.TerminalNode); ok {
		return terminal.GetText()
	}
	if ctx, ok := node.(antlr.RuleNode); ok {
		return ctx.GetText()
	}
	return "unknown"
}

func (g *GoCodeGenerator) parseParameterList(paramList string) []string {
	// Handle array syntax [param1 param2] or []interface{}{param1, param2}
	trimmed := strings.TrimSpace(paramList)

	if strings.HasPrefix(trimmed, "[") && strings.HasSuffix(trimmed, "]") && !strings.Contains(trimmed, "interface{}") {
		// Vex format - requires explicit type annotations
		inner := strings.TrimSpace(trimmed[1 : len(trimmed)-1])
		if inner == "" {
			return []string{}
		}
		result := g.parseVexParameterList(inner)
		if result == nil {
			return nil // Error: missing type annotations
		}
		return result
	} else if strings.HasPrefix(trimmed, "[]interface{}") {
		// Go format - extract parameter names from comma-separated list
		if start := strings.Index(trimmed, "}{"); start != -1 {
			start += 2
			if end := strings.LastIndex(trimmed, "}"); end > start {
				inner := strings.TrimSpace(trimmed[start:end])
				if inner == "" {
					return []string{}
				}
				params := strings.Split(inner, ",")
				for i, param := range params {
					params[i] = strings.TrimSpace(param)
				}
				// Parse type annotations from comma-separated format like ["x:", "int", "y:", "int"]
				return g.parseGoFormatParams(params)
			}
		}
	}

	return []string{}
}

// parseGoFormatParams parses comma-separated Go format parameter list with type annotations
// Input: ["x:", "int", "y:", "int"] -> Output: ["x", "y"]
func (g *GoCodeGenerator) parseGoFormatParams(params []string) []string {
	var result []string

	for i := 0; i < len(params); {
		param := params[i]

		// Check if this is a parameter name ending with ":"
		if strings.HasSuffix(param, ":") {
			paramName := strings.TrimSuffix(param, ":")
			result = append(result, paramName)
			// Skip the next token which should be the type
			i += 2
		} else {
			// Handle malformed case - just skip
			i += 1
		}
	}

	return result
}

// parseVexParameterList parses Vex parameter list with required type annotations
// Only supports explicit types: "x: int y: string z: bool" syntax
func (g *GoCodeGenerator) parseVexParameterList(paramListInner string) []string {
	tokens := strings.Fields(paramListInner)
	var params []string

	for i := 0; i < len(tokens); {
		token := tokens[i]

		// Check if this token ends with ":" indicating type annotation follows
		if strings.HasSuffix(token, ":") && i+1 < len(tokens) {
			// param: type format - "x:" followed by "int"
			paramName := strings.TrimSuffix(token, ":")
			params = append(params, paramName)
			i += 2 // Skip param: and type
		} else if strings.Contains(token, ":") {
			// param:type format (no space) - "x:int"
			parts := strings.Split(token, ":")
			if len(parts) == 2 && parts[1] != "" {
				paramName := parts[0]
				params = append(params, paramName)
				i += 1 // Skip this combined token
			} else {
				// ERROR: Malformed type annotation
				return nil
			}
		} else {
			// ERROR: param without type annotation - not allowed in explicit-only mode
			return nil
		}
	}

	return params
}

func (g *GoCodeGenerator) buildFinalCode() string {
	var result strings.Builder

	// Package declaration
	result.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	// Imports
	if len(g.imports) > 0 {
		for importPath, alias := range g.imports {
			if g.config.IgnoreImports != nil && g.config.IgnoreImports[importPath] {
				continue
			}
			if alias != "" {
				result.WriteString(fmt.Sprintf("import %s \"%s\"\n", alias, importPath))
			} else {
				result.WriteString(fmt.Sprintf("import \"%s\"\n", importPath))
			}
		}
		result.WriteString("\n")
	}

	// Main function
	result.WriteString("func main() {\n")

	// Add the generated code with proper indentation
	lines := strings.Split(g.output.String(), "\n")
	for _, line := range lines {
		if strings.TrimSpace(line) != "" {
			result.WriteString("\t" + line + "\n")
		}
	}

	result.WriteString("}\n")

	return result.String()
}

func isNumber(s string) bool {
	if len(s) == 0 {
		return false
	}
	for _, r := range s {
		if r < '0' || r > '9' {
			return false
		}
	}
	return true
}

// convertVexToGoIdentifier converts Vex identifiers (with hyphens) to Go identifiers (with underscores)
func convertVexToGoIdentifier(vexIdentifier string) string {
	return strings.ReplaceAll(vexIdentifier, "-", "_")
}

// isPackageVariable checks if a name refers to a package variable (not a function)
func isPackageVariable(name string) bool {
	// Known package variables
	packageVars := map[string]bool{
		"os.Args": true,
		// Add more as needed
	}
	return packageVars[name]
}

// Interface types (to avoid import cycles)
type AST interface {
	Accept(visitor ASTVisitor) error
}

type ASTVisitor interface {
	VisitProgram(ctx *parser.ProgramContext) error
	VisitList(ctx *parser.ListContext) (Value, error)
	VisitArray(ctx *parser.ArrayContext) (Value, error)
	VisitTerminal(node antlr.TerminalNode) (Value, error)
}

type Value interface {
	String() string
	Type() string
}

type SymbolTable interface {
	Define(name string, value Value) error
	Lookup(name string) (Value, bool)
	EnterScope()
	ExitScope()
}

// generateMacro handles macro definitions (compile-time constructs)
func (g *GoCodeGenerator) generateMacro(args []string) (Value, error) {
	// Macro definitions are compile-time constructs and don't generate runtime code
	// They are handled by the macro expansion phase, so we just return a no-op
	return analysis.NewBasicValue("", "void"), nil
}
