package main

import (
	"fmt"
	"os"

	"grammar-validator/parser"

	"github.com/antlr4-go/antlr/v4"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <file.vx> [file2.vx ...]\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "       %s --valid <valid-files...>\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "       %s --invalid <invalid-files...>\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "\nValidates Vex grammar by parsing .vx files using generated ANTLR parser\n")
		fmt.Fprintf(os.Stderr, "\nModes:\n")
		fmt.Fprintf(os.Stderr, "  --valid   : Files MUST parse successfully (CI fails if they don't)\n")
		fmt.Fprintf(os.Stderr, "  --invalid : Files MUST fail to parse (CI fails if they do)\n")
		fmt.Fprintf(os.Stderr, "  default   : Report all results, fail CI if any file fails\n")
		fmt.Fprintf(os.Stderr, "\nNote: This tool requires generated Vex parser files to be present.\n")
		fmt.Fprintf(os.Stderr, "Run 'antlr -Dlanguage=Go -listener -visitor Vex.g4 -o parser/' first.\n")
		os.Exit(1)
	}

	// Check if parser files exist
	if !filesExist("parser/vex_lexer.go", "parser/vex_parser.go") {
		fmt.Fprintf(os.Stderr, "âŒ Generated Vex parser files not found.\n")
		fmt.Fprintf(os.Stderr, "This tool needs parser/vex_lexer.go and parser/vex_parser.go to be present.\n")
		fmt.Fprintf(os.Stderr, "These are generated by ANTLR from the Vex.g4 grammar file.\n")
		os.Exit(1)
	}

	// Parse command line arguments
	var mode string
	var files []string
	
	if os.Args[1] == "--valid" || os.Args[1] == "--invalid" {
		mode = os.Args[1][2:] // Remove "--" prefix
		files = os.Args[2:]
	} else {
		mode = "default"
		files = os.Args[1:]
	}

	var failedFiles []string
	var unexpectedResults []string

	for _, filename := range files {
		fmt.Printf("\nTesting: %s\n", filename)

		// Read file content
		content, err := os.ReadFile(filename)
		if err != nil {
			fmt.Printf("âŒ Failed to read %s: %v\n", filename, err)
			failedFiles = append(failedFiles, filename)
			continue
		}

		// Create input stream
		inputStream := antlr.NewInputStream(string(content))

		// Create lexer
		lexer := parser.NewVexLexer(inputStream)

		// Create token stream
		tokenStream := antlr.NewCommonTokenStream(lexer, 0)

		// Create parser
		vexParser := parser.NewVexParser(tokenStream)

		// Add error listener to catch syntax errors
		errorListener := &ErrorListener{filename: filename}
		vexParser.RemoveErrorListeners()
		vexParser.AddErrorListener(errorListener)

		// Parse starting from the 'sp' rule (root rule)  
		tree := vexParser.Sp()

		// Check results based on mode
		if errorListener.hasError {
			if mode == "invalid" {
				fmt.Printf("âœ… %s failed as expected (invalid test case)\n", filename)
			} else {
				fmt.Printf("âŒ %s failed to parse\n", filename)
				failedFiles = append(failedFiles, filename)
			}
		} else {
			if mode == "valid" || mode == "default" {
				fmt.Printf("âœ… %s parsed successfully\n", filename)
				fmt.Printf("Parse tree: %s\n", tree.ToStringTree(vexParser.GetRuleNames(), vexParser))
			} else { // mode == "invalid"
				fmt.Printf("âŒ %s parsed successfully but should have failed (invalid test case)\n", filename)
				unexpectedResults = append(unexpectedResults, filename)
			}
		}
	}

	// Report final results
	hasErrors := len(failedFiles) > 0 || len(unexpectedResults) > 0
	
	if len(failedFiles) > 0 {
		fmt.Println("\nğŸ’¥ The following files failed to parse:")
		for _, file := range failedFiles {
			fmt.Printf("  - %s\n", file)
		}
	}
	
	if len(unexpectedResults) > 0 {
		fmt.Println("\nâš ï¸  The following invalid test files unexpectedly succeeded:")
		for _, file := range unexpectedResults {
			fmt.Printf("  - %s\n", file)
		}
	}
	
	if hasErrors {
		fmt.Println("\nâŒ Grammar validation failed!")
		os.Exit(1)
	} else {
		switch mode {
		case "valid":
			fmt.Println("\nğŸ‰ All valid example files parsed successfully!")
		case "invalid":
			fmt.Println("\nğŸ‰ All invalid example files failed as expected!")
		default:
			fmt.Println("\nğŸ‰ All example files produced expected results!")
		}
	}
}

// ErrorListener captures syntax errors
type ErrorListener struct {
	*antlr.DefaultErrorListener
	filename string
	hasError bool
}

func (el *ErrorListener) SyntaxError(recognizer antlr.Recognizer, offendingSymbol interface{}, line, column int, msg string, e antlr.RecognitionException) {
	fmt.Printf("âŒ Syntax error in %s at line %d:%d - %s\n", el.filename, line, column, msg)
	el.hasError = true
}

func filesExist(files ...string) bool {
	for _, file := range files {
		if _, err := os.Stat(file); err != nil {
			return false
		}
	}
	return true
}